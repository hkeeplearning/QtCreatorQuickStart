Qt对象模型与容器类。

- 对象模型
- 信号和槽
- 属性系统
- 对象树
- 拥有权
- 元对象
- 容器类
- QString
- QByteArray
- QVariant

## 对象模型

Qt新对象模型特性

- 对象间通信机制——信号和槽
- 可查询，可设计的对象属性系统
- 强大的事件和事件过滤器
- 基于上下文的国际化字符串翻译机制
- 完善的定时器驱动，可以在一个事件驱动的gui中处理多个任务
- 分层结构的，可查询的对象树，它使用一种很自然的方式来组织对象的拥有权
- 守卫指针
- 动态对象转换机制
- 支持创建自定义类型

### 信号和槽

一个信号可以关联多个槽，多个信号也可以关联到一个槽上。

如果存在多个槽关联到一个信号上，那么当信号被发射时，这些槽将会一个接一个地执行，执行顺序与关联顺序相同。

### 属性系统

基于元对象的属性系统，可以在运行Qt的平台上支持标准C++编译器。

要在一个类中声明属性，该类必须继承自QObject类，而且还要在声明前使用Q_PROPERTY()宏

### 对象树和拥有权

Qt中使用对象树来组织和管理所有的QObject类及其子类。

当创建一个QObject时，如果使用了其他的对象作为其父对象，那么这个对象就会被添加到父对象的列表中，当父对象销毁时，这个QObject对象也会被销毁。

### 元对象系统

Qt中的元对象系统 Meta-Object System 提供了对象间通信的信号和槽机制，运行时类型信息，和动态属性系统。元对象系统基于以下三个条件

- 该类集成自QObject
- 必须在类的私有声明区声明 Q_OBJECT 宏
- 元对象编译器 moc 为QObject的子类实现元对象特性提供必要的代码

## QString

隐式共享（又，写时复制）Qt中很多C++类使用隐式数据共享来尽可能地提高资源使用率和减少复制操作。使用隐式共享类作为参数传递既安全又有效，因为只有一个指向该数据的指针被传递了。只有当函数向它写入时才会复制该数据。

```C++
QPixelmap p1, p2;
p1.load("image.png");
p2 = p1; // p1和p2共享数据
QPainter paint;
paint.begin(&p2); // p2被修改
paint.drawText(0, 50, "Hi");
paint.end();
```

可以使用 canConvert 函数来判断，如果可以转换返回 true。也可以使用convert函数来讲一个类型转换为不同的类型，如果转换成功返回true，如果不能转换，variant对象将会被清空，并且返回false。对于同一转换，canConvert和convert并不一定返回同样的结果，这通常是因为 canConvert 只报告 QVariant进行连个类型之间进行转换的能力，但是如果提供的数据不合适，那么转换就会失败，convet的返回就与canConvert不同了。

